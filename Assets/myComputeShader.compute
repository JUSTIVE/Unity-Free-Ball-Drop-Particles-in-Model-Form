// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct data{
	float3 pos;
	float3 vel;
    float mass;
};
RWStructuredBuffer<data> value;
float3 sphere1;
float deltaT;

[numthreads(8,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	
	float boundary = -0.995f;
    float3 force;
    float3 gravity = float3(0, -9.81f, 0);

	float3 p = value[id.x].pos;
	float3 v = value[id.x].vel;
    float radius = 1.0f;

    float3 acc= gravity/value[id.x].mass;
	//update velocity 
    //Implicit Euler
    /*
    v += acc* deltaT;
	p += (v*deltaT);
    /*/
    // in forth Runge-Kutta
    
    float3 K1_Vel = gravity;//t0의 가속도
    float3 K2_Vel = gravity; //1/2dt 의 가속도
    float3 K3_Vel = gravity;
    float3 K4_Vel = gravity;
    v = v + deltaT * ((K1_Vel + (2 * K2_Vel) + (2 * K3_Vel) + K4_Vel) / 6);
    float3 K1_Pos = v;
    float3 K2_Pos = ((0.5f * deltaT) * K1_Pos) * deltaT;
    float3 K3_Pos = ((0.5f * deltaT) * K2_Pos) * deltaT;
    float3 K4_Pos = ((p) + deltaT * K3_Pos) * deltaT;
    
    p = p + deltaT * ((K1_Pos + (2 * K2_Pos) + (2 * K3_Pos) + K4_Pos) / 6);

    //*/

	if (p.y < boundary) {
		v.y = v.y*-0.9f;
		p.y = boundary;
		//xv = 0.1;
    }

    //collision from box
    float boxScale = 2.5f;
    if (p.x < -1*boxScale)
    {
        v.x = v.x * -0.9f;
        p.x = -1 * boxScale;
    }
    if (p.x > 1 * boxScale)
    {
        v.x = v.x * -0.9f;
        p.x = 1 * boxScale;
    }
    if (p.z < -1 * boxScale)
    {
        v.z = v.z * -0.9f;
        p.z = -1 * boxScale;
    }
    if (p.z > 1 * boxScale)
    {
        v.z = v.z * -0.9f;
        p.z = 1 * boxScale;
    }

    value[id.x].vel = v;
    value[id.x].pos = p;
    
    
    if (distance(value[id.x].pos, float3(sphere1)) < radius)
    {
        float3 temppos = (value[id.x].pos- p) / 2 + p;
        float tempdist = distance(temppos, sphere1);
        float3 left = p;
        float3 right = value[id.x].pos;
        for (int i = 0; i < 100; i++)
        {
            if (tempdist == radius)
            {
                break;
            }
            else if (tempdist > radius)
            {
                right = temppos;
                temppos = (temppos - left) / 2 + p;
                tempdist = distance(temppos, sphere1);
            }
            else
            {
                left = temppos;
                temppos = (right - temppos) / 2 + p;
                tempdist = distance(temppos, sphere1);
            }
        }
        //just assume the point temppos after loop satisfying the accurate position of we want
        float3 tempdir = temppos - sphere1;

        //value[id.x].pos = temppos;
        value[id.x].pos = normalize(tempdir) * radius + sphere1;
        float3 dir = value[id.x].pos - sphere1;
        float3 n = normalize(dir);
        value[id.x].vel = (value[id.x].vel - 2 * (dot(value[id.x].vel, n)) * n)*0.9f;
        //value[id.x].vel = normalize(float4(dir, 0.0f)).xyz * length(v)*0.9f;
    }
}
